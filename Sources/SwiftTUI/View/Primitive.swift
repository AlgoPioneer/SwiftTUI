import Foundation

/// Primitive views have a `Body` type of `Never` and have custom logic for
/// building and updating nodes created for them in the view graph.
///
/// Although primitive views have complete control of how they build and update
/// nodes, we can generally put primitive views into one of four categories:
///
/// * **Unary views** will generate a single control.
///
/// * **Structural views** use unary views to generate multiple controls, or
/// none, or a dynamic number of controls.
///
/// * **Modifiers** change the controls that an underlying view generates
/// individually.
///
/// * **Container views** define a container for the controls generated by the
/// underlying view. They can lazily load the controls.
///
/// Note that a view is a description of how to create a **list** of controls.
protocol Primitive: NodeBuilder {}

extension Primitive {
    public var body: Never { fatalError("Cannot evaluate body of primitive view") }
}

extension View {
    static var size: Int? {
        if let I = Self.self as? Primitive.Type {
            return I.size
        }
        return Body.size
    }
}

extension View {
    var nodeBuilder: NodeBuilder {
        if let primitiveView = self as? Primitive {
            return primitiveView
        }
        return Composed(view: self)
    }
}
